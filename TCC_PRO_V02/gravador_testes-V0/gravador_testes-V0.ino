/* software for recording hexadecimal files, this program must be recorded on an ESP32 - DEVKITV1, 
*  there is an android application that communicates with this program, 
*  this application sends hexadeciamis data via bluetooth to the ESP32 card - DEVKITV1.
*/
#include <SPI.h>
#include <vector>
#include "BluetoothSerial.h"

#if !defined(CONFIG_BT_ENABLED) || !defined(CONFIG_BLUEDROID_ENABLED)
#error Bluetooth is not enabled! Please run make menuconfig to and enable it
#endif


const int SLAVE_SELECT_PIN=5;
const int START=15;
const int RECEIVING_BT_DATA_LED=2;

BluetoothSerial SerialBT;
std::vector<uint8_t> newBytes = {};

const std::vector<uint8_t> BOOTLOADER = {
    0x11, 0x24, 0x84, 0xB7, 0x14, 0xBE, 0x81, 0xFF, 0xF0, 0xD0, 0x85, 0xE0, 0x80, 0x93, 0x81, 0x00,
    0x82, 0xE0, 0x80, 0x93, 0xC0, 0x00, 0x88, 0xE1, 0x80, 0x93, 0xC1, 0x00, 0x86, 0xE0, 0x80, 0x93,
    0xC2, 0x00, 0x80, 0xE1, 0x80, 0x93, 0xC4, 0x00, 0x8E, 0xE0, 0xC9, 0xD0, 0x25, 0x9A, 0x86, 0xE0,
    0x20, 0xE3, 0x3C, 0xEF, 0x91, 0xE0, 0x30, 0x93, 0x85, 0x00, 0x20, 0x93, 0x84, 0x00, 0x96, 0xBB,
    0xB0, 0x9B, 0xFE, 0xCF, 0x1D, 0x9A, 0xA8, 0x95, 0x81, 0x50, 0xA9, 0xF7, 0xCC, 0x24, 0xDD, 0x24,
    0x88, 0x24, 0x83, 0x94, 0xB5, 0xE0, 0xAB, 0x2E, 0xA1, 0xE1, 0x9A, 0x2E, 0xF3, 0xE0, 0xBF, 0x2E,
    0xA2, 0xD0, 0x81, 0x34, 0x61, 0xF4, 0x9F, 0xD0, 0x08, 0x2F, 0xAF, 0xD0, 0x02, 0x38, 0x11, 0xF0,
    0x01, 0x38, 0x11, 0xF4, 0x84, 0xE0, 0x01, 0xC0, 0x83, 0xE0, 0x8D, 0xD0, 0x89, 0xC0, 0x82, 0x34,
    0x11, 0xF4, 0x84, 0xE1, 0x03, 0xC0, 0x85, 0x34, 0x19, 0xF4, 0x85, 0xE0, 0xA6, 0xD0, 0x80, 0xC0,
    0x85, 0x35, 0x79, 0xF4, 0x88, 0xD0, 0xE8, 0x2E, 0xFF, 0x24, 0x85, 0xD0, 0x08, 0x2F, 0x10, 0xE0,
    0x10, 0x2F, 0x00, 0x27, 0x0E, 0x29, 0x1F, 0x29, 0x00, 0x0F, 0x11, 0x1F, 0x8E, 0xD0, 0x68, 0x01,
    0x6F, 0xC0, 0x86, 0x35, 0x21, 0xF4, 0x84, 0xE0, 0x90, 0xD0, 0x80, 0xE0, 0xDE, 0xCF, 0x84, 0x36,
    0x09, 0xF0, 0x40, 0xC0, 0x70, 0xD0, 0x6F, 0xD0, 0x08, 0x2F, 0x6D, 0xD0, 0x80, 0xE0, 0xC8, 0x16,
    0x80, 0xE7, 0xD8, 0x06, 0x18, 0xF4, 0xF6, 0x01, 0xB7, 0xBE, 0xE8, 0x95, 0xC0, 0xE0, 0xD1, 0xE0,
    0x62, 0xD0, 0x89, 0x93, 0x0C, 0x17, 0xE1, 0xF7, 0xF0, 0xE0, 0xCF, 0x16, 0xF0, 0xE7, 0xDF, 0x06,
    0x18, 0xF0, 0xF6, 0x01, 0xB7, 0xBE, 0xE8, 0x95, 0x68, 0xD0, 0x07, 0xB6, 0x00, 0xFC, 0xFD, 0xCF,
    0xA6, 0x01, 0xA0, 0xE0, 0xB1, 0xE0, 0x2C, 0x91, 0x30, 0xE0, 0x11, 0x96, 0x8C, 0x91, 0x11, 0x97,
    0x90, 0xE0, 0x98, 0x2F, 0x88, 0x27, 0x82, 0x2B, 0x93, 0x2B, 0x12, 0x96, 0xFA, 0x01, 0x0C, 0x01,
    0x87, 0xBE, 0xE8, 0x95, 0x11, 0x24, 0x4E, 0x5F, 0x5F, 0x4F, 0xF1, 0xE0, 0xA0, 0x38, 0xBF, 0x07,
    0x51, 0xF7, 0xF6, 0x01, 0xA7, 0xBE, 0xE8, 0x95, 0x07, 0xB6, 0x00, 0xFC, 0xFD, 0xCF, 0x97, 0xBE,
    0xE8, 0x95, 0x26, 0xC0, 0x84, 0x37, 0xB1, 0xF4, 0x2E, 0xD0, 0x2D, 0xD0, 0xF8, 0x2E, 0x2B, 0xD0,
    0x3C, 0xD0, 0xF6, 0x01, 0xEF, 0x2C, 0x8F, 0x01, 0x0F, 0x5F, 0x1F, 0x4F, 0x84, 0x91, 0x1B, 0xD0,
    0xEA, 0x94, 0xF8, 0x01, 0xC1, 0xF7, 0x08, 0x94, 0xC1, 0x1C, 0xD1, 0x1C, 0xFA, 0x94, 0xCF, 0x0C,
    0xD1, 0x1C, 0x0E, 0xC0, 0x85, 0x37, 0x39, 0xF4, 0x28, 0xD0, 0x8E, 0xE1, 0x0C, 0xD0, 0x85, 0xE9,
    0x0A, 0xD0, 0x8F, 0xE0, 0x7A, 0xCF, 0x81, 0x35, 0x11, 0xF4, 0x88, 0xE0, 0x18, 0xD0, 0x1D, 0xD0,
    0x80, 0xE1, 0x01, 0xD0, 0x65, 0xCF, 0x98, 0x2F, 0x80, 0x91, 0xC0, 0x00, 0x85, 0xFF, 0xFC, 0xCF,
    0x90, 0x93, 0xC6, 0x00, 0x08, 0x95, 0x80, 0x91, 0xC0, 0x00, 0x87, 0xFF, 0xFC, 0xCF, 0x80, 0x91,
    0xC0, 0x00, 0x84, 0xFD, 0x01, 0xC0, 0xA8, 0x95, 0x80, 0x91, 0xC6, 0x00, 0x08, 0x95, 0xE0, 0xE6,
    0xF0, 0xE0, 0x98, 0xE1, 0x90, 0x83, 0x80, 0x83, 0x08, 0x95, 0xED, 0xDF, 0x80, 0x32, 0x19, 0xF0,
    0x88, 0xE0, 0xF5, 0xDF, 0xFF, 0xCF, 0x84, 0xE1, 0xDE, 0xCF, 0x1F, 0x93, 0x18, 0x2F, 0xE3, 0xDF,
    0x11, 0x50, 0xE9, 0xF7, 0xF2, 0xDF, 0x1F, 0x91, 0x08, 0x95, 0x80, 0xE0, 0xE8, 0xDF, 0xEE, 0x27,
    0xFF, 0x27, 0x09, 0x94, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
};

const std::vector<uint8_t> FINAL_FLASH = {
    0x04, 0x04
};

void setup() {
    pinMode(SLAVE_SELECT_PIN, OUTPUT);
    digitalWrite(SLAVE_SELECT_PIN, HIGH);
    pinMode(START, INPUT_PULLUP);
    pinMode(RECEIVING_BT_DATA_LED, OUTPUT);
    SerialBT.begin("PLC - Bluetooth Recorder");
    // Serial.begin(9600);
}

void loop() {
    if (SerialBT.available()) {
        newBytes.push_back(SerialBT.read());
        digitalWrite(RECEIVING_BT_DATA_LED, HIGH);
    }
    if(digitalRead(START)==LOW) {
        digitalWrite(RECEIVING_BT_DATA_LED, HIGH);
        recordFlash();
    }
    delay(10);
    digitalWrite(RECEIVING_BT_DATA_LED, LOW);
}

void recordFlash() {
    bool success = false;
    int contErros = 0;
    while ((success == false) && (contErros <= 4)) {
        SPI.begin(18, 19, 23, 5);
        delay(200);
        habilitaProg();
        delay(10);
        success = writeFullProgram();
        delay(10);
        contErros++;
        SPI.end();
    }
    if (success == true) {
        // Serial.println("\nGreat job!");
        digitalWrite(RECEIVING_BT_DATA_LED, LOW);
        delay(1000);
        digitalWrite(RECEIVING_BT_DATA_LED, HIGH);
        delay(1000);
        digitalWrite(RECEIVING_BT_DATA_LED, LOW);
        delay(1000);
        digitalWrite(RECEIVING_BT_DATA_LED, HIGH);
        delay(1000);
        digitalWrite(RECEIVING_BT_DATA_LED, LOW);
        delay(1000);
        digitalWrite(RECEIVING_BT_DATA_LED, HIGH);
        newBytes = {};
    }
    digitalWrite(SLAVE_SELECT_PIN, HIGH);
}

bool writeFullProgram() {
    bool newFlashRes = true;
    bool bootloaderRes = false;
    bool finalFlashRes = false;
    spi_transfer4(0xAC, 0x80, 0x00, 0x00);
    delay(10);
    if (newBytes.size() >= 1) {
        newFlashRes = writeProgram(newBytes, 0x0000);
        delay(10);
    }
    bootloaderRes = writeProgram(BOOTLOADER, 0x7F00);
    delay(10);
    finalFlashRes = writeProgram(FINAL_FLASH, 0x7FFE);
    delay(10);
    if (newFlashRes == false || bootloaderRes == false || finalFlashRes == false) {
        return false;
    }
    return true;
}

// void printFlashByAddress(uint16_t addr) {
//     uint16_t res = 0;
//     uint8_t aux = 0;
//     uint8_t high = spi_transfer4(0x28, addr >> 8, addr, 0x00);
//     uint8_t low = spi_transfer4(0x20, addr >> 8, addr, 0x00);
//     aux |= (low >> 4);
//     // if(aux == 0) {
//     //   Serial.print("0");
//     // }
//     res |= (low << 8);
//     res |= (high);
//     // Serial.print(res, HEX);
// }

uint16_t readFlashByAddress(uint16_t addr) {
    uint16_t res = 0;
    uint8_t high = spi_transfer4(0x28, addr >> 8, addr, 0x00);
    uint8_t low = spi_transfer4(0x20, addr >> 8, addr, 0x00);
    res |= (low << 8);
    res |= (high);
    return res;
}

// void printMemory(uint16_t startAddr, uint16_t finalAddr) {
//     for (uint16_t addr = startAddr; addr < finalAddr; addr++) {
//         if(((addr % 8) == 0) && addr != 0) {
//             // Serial.println();
//         }
//         // printFlashByAddress(addr);
//     }
// }

void habilitaProg() {
    uint8_t response = 0;
    digitalWrite(SLAVE_SELECT_PIN, LOW);
    delay(1000);
    // Serial.print("\nHabilitando programacao...\t");
    SPI.transfer(0xAC);
    SPI.transfer(0x53);
    response = SPI.transfer(0x00);
    SPI.transfer(0x00);
    // response != 0x53 ? Serial.print("NAO OK\n") : Serial.print("OK\n");
    return;
}

void loadHighByte(uint16_t addr, uint8_t byte) {
    spi_transfer4(0x48, 0x00, addr, byte);
    return;
}

void loadLowByte(uint16_t addr, uint8_t byte) {
    spi_transfer4(0x40, 0x00, addr, byte);
    return;
}

void writeBytes(uint16_t addr) {
    spi_transfer4(0x4C, addr >> 8, addr, 0x00);
    return;
}

bool writeProgram(std::vector<uint8_t> program, uint16_t addr) {
    uint16_t flashAddr = addr; 
    int cont = 0;
    int i = 0;
    int contErrors = 0;
    for (i = 0; i<program.size(); i += 2) {
        loadLowByte(flashAddr, program[i]);
        loadHighByte(flashAddr, program[i+1]);
        flashAddr ++;
        cont ++;
        if(cont == 64) {
            writeBytes(flashAddr - cont);
            delay(10);
            if (!isMemoryCorrect(flashAddr, program, i - ((64*2)-2), 64)) {
                if(contErrors > 6) {
                    digitalWrite(RECEIVING_BT_DATA_LED, LOW);
                    delay(100);
                    digitalWrite(RECEIVING_BT_DATA_LED, HIGH);
                    delay(100);
                    digitalWrite(RECEIVING_BT_DATA_LED, LOW);
                    delay(100);
                    digitalWrite(RECEIVING_BT_DATA_LED, HIGH);
                    return false;
                }
                // Serial.print("flashAddr : ");
                // Serial.print(flashAddr, HEX);
                // Serial.print(", valor de i: ");
                // Serial.print(i);
                contErrors++;
                flashAddr -= 64;
                i -= 128;
            }
            cont = 0;
        }
    }
    if (cont == 0) {
        return true;
    }
    writeBytes(flashAddr - cont);
    delay(10);
    // posso refatorar aqui, colocar direto o return recebendo da função
    if (!isMemoryCorrect(flashAddr, program, i - (cont*2), (i/2))) {
        return false;
    }
    return true;
}

bool isMemoryCorrect(uint16_t flashAddr, std::vector<uint8_t> program, int dataAddr, int wordsQuantity) {
    uint16_t memoryBytes = 0;
    int dataIndex = dataAddr;
    for (uint16_t i = flashAddr - wordsQuantity; i < flashAddr; i++) {
        uint16_t dataBytes = 0;
        memoryBytes = readFlashByAddress(i);
        delay(10);
        uint8_t low = program[dataIndex];
        uint8_t high = program[dataIndex+1];
        dataBytes |= (low << 8);
        dataBytes |= (high);
        if (dataBytes != memoryBytes) {
            // Serial.println("Yes, it's diferent ");
            // Serial.print("bytes on data: ");
            // Serial.print(dataBytes, HEX);
            // Serial.print(", bytes on memory: ");
            // Serial.print(memoryBytes, HEX);
            // Serial.println();
            return false;
        }
        dataIndex += 2;
    }
    return true;
}

uint8_t spi_transfer4(uint8_t a1, uint8_t a2, uint8_t a3, uint8_t a4) {
    SPI.transfer(a1);
    SPI.transfer(a2);
    SPI.transfer(a3);
    return SPI.transfer(a4);
}
